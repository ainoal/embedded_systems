
KeypadTest.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000000a  00800100  000004be  00000552  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000004be  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000006  0080010a  0080010a  0000055c  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000055c  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000058c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000060  00000000  00000000  000005cc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00000e22  00000000  00000000  0000062c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000089b  00000000  00000000  0000144e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000061d  00000000  00000000  00001ce9  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000098  00000000  00000000  00002308  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000004ae  00000000  00000000  000023a0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000051d  00000000  00000000  0000284e  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000040  00000000  00000000  00002d6b  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
   4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  2c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  48:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
  68:	11 24       	eor	r1, r1
  6a:	1f be       	out	0x3f, r1	; 63
  6c:	cf ef       	ldi	r28, 0xFF	; 255
  6e:	d8 e0       	ldi	r29, 0x08	; 8
  70:	de bf       	out	0x3e, r29	; 62
  72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
  74:	11 e0       	ldi	r17, 0x01	; 1
  76:	a0 e0       	ldi	r26, 0x00	; 0
  78:	b1 e0       	ldi	r27, 0x01	; 1
  7a:	ee eb       	ldi	r30, 0xBE	; 190
  7c:	f4 e0       	ldi	r31, 0x04	; 4
  7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
  80:	05 90       	lpm	r0, Z+
  82:	0d 92       	st	X+, r0
  84:	aa 30       	cpi	r26, 0x0A	; 10
  86:	b1 07       	cpc	r27, r17
  88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
  8a:	21 e0       	ldi	r18, 0x01	; 1
  8c:	aa e0       	ldi	r26, 0x0A	; 10
  8e:	b1 e0       	ldi	r27, 0x01	; 1
  90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
  92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
  94:	a0 31       	cpi	r26, 0x10	; 16
  96:	b2 07       	cpc	r27, r18
  98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
  9a:	0e 94 90 00 	call	0x120	; 0x120 <main>
  9e:	0c 94 5d 02 	jmp	0x4ba	; 0x4ba <_exit>

000000a2 <__bad_interrupt>:
  a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <led_test>:

#define BITMASK_D 0b11000000
#define BITMASK_B 0b00111111

void led_test(void){
    PORTD &= ~(1 << PD3);
  a6:	8b b1       	in	r24, 0x0b	; 11
  a8:	87 7f       	andi	r24, 0xF7	; 247
  aa:	8b b9       	out	0x0b, r24	; 11
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
  ac:	2f ef       	ldi	r18, 0xFF	; 255
  ae:	83 ed       	ldi	r24, 0xD3	; 211
  b0:	90 e3       	ldi	r25, 0x30	; 48
  b2:	21 50       	subi	r18, 0x01	; 1
  b4:	80 40       	sbci	r24, 0x00	; 0
  b6:	90 40       	sbci	r25, 0x00	; 0
  b8:	e1 f7       	brne	.-8      	; 0xb2 <led_test+0xc>
  ba:	00 c0       	rjmp	.+0      	; 0xbc <led_test+0x16>
  bc:	00 00       	nop
    _delay_ms(1000);
    PORTD |= (1 << PD3);
  be:	8b b1       	in	r24, 0x0b	; 11
  c0:	88 60       	ori	r24, 0x08	; 8
  c2:	8b b9       	out	0x0b, r24	; 11
  c4:	2f ef       	ldi	r18, 0xFF	; 255
  c6:	83 ed       	ldi	r24, 0xD3	; 211
  c8:	90 e3       	ldi	r25, 0x30	; 48
  ca:	21 50       	subi	r18, 0x01	; 1
  cc:	80 40       	sbci	r24, 0x00	; 0
  ce:	90 40       	sbci	r25, 0x00	; 0
  d0:	e1 f7       	brne	.-8      	; 0xca <led_test+0x24>
  d2:	00 c0       	rjmp	.+0      	; 0xd4 <led_test+0x2e>
  d4:	00 00       	nop
    _delay_ms(1000);
    PORTD &= ~(1 << PD3);
  d6:	8b b1       	in	r24, 0x0b	; 11
  d8:	87 7f       	andi	r24, 0xF7	; 247
  da:	8b b9       	out	0x0b, r24	; 11
  dc:	2f ef       	ldi	r18, 0xFF	; 255
  de:	83 ed       	ldi	r24, 0xD3	; 211
  e0:	90 e3       	ldi	r25, 0x30	; 48
  e2:	21 50       	subi	r18, 0x01	; 1
  e4:	80 40       	sbci	r24, 0x00	; 0
  e6:	90 40       	sbci	r25, 0x00	; 0
  e8:	e1 f7       	brne	.-8      	; 0xe2 <led_test+0x3c>
  ea:	00 c0       	rjmp	.+0      	; 0xec <led_test+0x46>
  ec:	00 00       	nop
  ee:	08 95       	ret

000000f0 <compare>:
    _delay_ms(1000);
}

int compare(char *password, char *given_password){
    if (strcmp(password, given_password) != 0) {
  f0:	0e 94 11 02 	call	0x422	; 0x422 <strcmp>
  f4:	89 2b       	or	r24, r25
  f6:	89 f0       	breq	.+34     	; 0x11a <compare+0x2a>
        led_test();
  f8:	0e 94 53 00 	call	0xa6	; 0xa6 <led_test>
        led_test();
  fc:	0e 94 53 00 	call	0xa6	; 0xa6 <led_test>
        led_test();
 100:	0e 94 53 00 	call	0xa6	; 0xa6 <led_test>
        led_test();
 104:	0e 94 53 00 	call	0xa6	; 0xa6 <led_test>
        led_test();
 108:	0e 94 53 00 	call	0xa6	; 0xa6 <led_test>
        led_test();
 10c:	0e 94 53 00 	call	0xa6	; 0xa6 <led_test>
        led_test();
 110:	0e 94 53 00 	call	0xa6	; 0xa6 <led_test>
        return 0;
 114:	80 e0       	ldi	r24, 0x00	; 0
 116:	90 e0       	ldi	r25, 0x00	; 0
 118:	08 95       	ret
    }
    else {
        return 1;
 11a:	81 e0       	ldi	r24, 0x01	; 1
 11c:	90 e0       	ldi	r25, 0x00	; 0
    }
}
 11e:	08 95       	ret

00000120 <main>:

int main(void)
{
 120:	cf 93       	push	r28
 122:	df 93       	push	r29
 124:	cd b7       	in	r28, 0x3d	; 61
 126:	de b7       	in	r29, 0x3e	; 62
 128:	6c 97       	sbiw	r28, 0x1c	; 28
 12a:	0f b6       	in	r0, 0x3f	; 63
 12c:	f8 94       	cli
 12e:	de bf       	out	0x3e, r29	; 62
 130:	0f be       	out	0x3f, r0	; 63
 132:	cd bf       	out	0x3d, r28	; 61
    /********************testing****************************/
    
    char input;
    FILE uart_output = FDEV_SETUP_STREAM(USART_transmit, NULL, _FDEV_SETUP_WRITE);
 134:	8e e0       	ldi	r24, 0x0E	; 14
 136:	9e 01       	movw	r18, r28
 138:	2f 5f       	subi	r18, 0xFF	; 255
 13a:	3f 4f       	sbci	r19, 0xFF	; 255
 13c:	79 01       	movw	r14, r18
 13e:	f9 01       	movw	r30, r18
 140:	28 2f       	mov	r18, r24
 142:	11 92       	st	Z+, r1
 144:	2a 95       	dec	r18
 146:	e9 f7       	brne	.-6      	; 0x142 <main+0x22>
 148:	92 e0       	ldi	r25, 0x02	; 2
 14a:	9c 83       	std	Y+4, r25	; 0x04
 14c:	23 e0       	ldi	r18, 0x03	; 3
 14e:	32 e0       	ldi	r19, 0x02	; 2
 150:	3a 87       	std	Y+10, r19	; 0x0a
 152:	29 87       	std	Y+9, r18	; 0x09
    FILE uart_input = FDEV_SETUP_STREAM(NULL, USART_receive, _FDEV_SETUP_READ);
 154:	8e 01       	movw	r16, r28
 156:	01 5f       	subi	r16, 0xF1	; 241
 158:	1f 4f       	sbci	r17, 0xFF	; 255
 15a:	f8 01       	movw	r30, r16
 15c:	11 92       	st	Z+, r1
 15e:	8a 95       	dec	r24
 160:	e9 f7       	brne	.-6      	; 0x15c <main+0x3c>
 162:	81 e0       	ldi	r24, 0x01	; 1
 164:	8a 8b       	std	Y+18, r24	; 0x12
 166:	8a e0       	ldi	r24, 0x0A	; 10
 168:	92 e0       	ldi	r25, 0x02	; 2
 16a:	9a 8f       	std	Y+26, r25	; 0x1a
 16c:	89 8f       	std	Y+25, r24	; 0x19
        
    USART_init(UBRR);
 16e:	87 e6       	ldi	r24, 0x67	; 103
 170:	90 e0       	ldi	r25, 0x00	; 0
 172:	0e 94 f8 01 	call	0x3f0	; 0x3f0 <USART_init>
        
    stdout = &uart_output;
 176:	ea e0       	ldi	r30, 0x0A	; 10
 178:	f1 e0       	ldi	r31, 0x01	; 1
 17a:	f3 82       	std	Z+3, r15	; 0x03
 17c:	e2 82       	std	Z+2, r14	; 0x02
    stdin = &uart_input;
 17e:	11 83       	std	Z+1, r17	; 0x01
 180:	00 83       	st	Z, r16
    char* password = "0123";
    char* given_password = "xxxx";
    int idx = 0;
    
    // Set digital pins 6-9 (rows) as input and 10-13 (columns) as output
    DDRD &= 0b00111111;
 182:	8a b1       	in	r24, 0x0a	; 10
 184:	8f 73       	andi	r24, 0x3F	; 63
 186:	8a b9       	out	0x0a, r24	; 10
    DDRB &= 0b11111100;
 188:	84 b1       	in	r24, 0x04	; 4
 18a:	8c 7f       	andi	r24, 0xFC	; 252
 18c:	84 b9       	out	0x04, r24	; 4
    DDRB |= 0b00111100;
 18e:	84 b1       	in	r24, 0x04	; 4
 190:	8c 63       	ori	r24, 0x3C	; 60
 192:	84 b9       	out	0x04, r24	; 4
 194:	8f e9       	ldi	r24, 0x9F	; 159
 196:	9f e0       	ldi	r25, 0x0F	; 15
 198:	01 97       	sbiw	r24, 0x01	; 1
 19a:	f1 f7       	brne	.-4      	; 0x198 <main+0x78>
 19c:	00 c0       	rjmp	.+0      	; 0x19e <main+0x7e>
 19e:	00 00       	nop
    _delay_ms(1);
    
    // Power the row pins
    PORTD |= 0b11000000;
 1a0:	8b b1       	in	r24, 0x0b	; 11
 1a2:	80 6c       	ori	r24, 0xC0	; 192
 1a4:	8b b9       	out	0x0b, r24	; 11
    PORTB |= 0b00000011;
 1a6:	85 b1       	in	r24, 0x05	; 5
 1a8:	83 60       	ori	r24, 0x03	; 3
 1aa:	85 b9       	out	0x05, r24	; 5
 1ac:	ef e9       	ldi	r30, 0x9F	; 159
 1ae:	ff e0       	ldi	r31, 0x0F	; 15
 1b0:	31 97       	sbiw	r30, 0x01	; 1
 1b2:	f1 f7       	brne	.-4      	; 0x1b0 <main+0x90>
 1b4:	00 c0       	rjmp	.+0      	; 0x1b6 <main+0x96>
 1b6:	00 00       	nop
    stdin = &uart_input;
    /******************************************************/
    
    char* password = "0123";
    char* given_password = "xxxx";
    int idx = 0;
 1b8:	00 e0       	ldi	r16, 0x00	; 0
 1ba:	10 e0       	ldi	r17, 0x00	; 0
    uint8_t portd_vals;
    
    while (1) 
    { 
        //_delay_ms(10);
        portd_vals = ((PIND & BITMASK_D) >> 6);
 1bc:	89 b1       	in	r24, 0x09	; 9
 1be:	28 2f       	mov	r18, r24
 1c0:	22 95       	swap	r18
 1c2:	26 95       	lsr	r18
 1c4:	26 95       	lsr	r18
 1c6:	23 70       	andi	r18, 0x03	; 3
        portb_vals = ((PINB & BITMASK_B) << 2);
 1c8:	93 b1       	in	r25, 0x03	; 3
 1ca:	89 2f       	mov	r24, r25
 1cc:	90 e0       	ldi	r25, 0x00	; 0
 1ce:	88 0f       	add	r24, r24
 1d0:	99 1f       	adc	r25, r25
 1d2:	88 0f       	add	r24, r24
 1d4:	99 1f       	adc	r25, r25
        keypad_vals = portd_vals | portb_vals;
 1d6:	82 2b       	or	r24, r18
        
        //printf("Keypad_vals %d", keypad_vals);
        keypad_vals &= 0b00001111;
 1d8:	8f 70       	andi	r24, 0x0F	; 15
        //printf("kp_vals: %d  portd_vals: %d  portb_vals: %d  PINB: %d\n\r", keypad_vals, portd_vals, portb_vals, PINB);
        
        if (keypad_vals != 0b00001111) {     // If any of column pins goes high
 1da:	8f 30       	cpi	r24, 0x0F	; 15
 1dc:	79 f3       	breq	.-34     	; 0x1bc <main+0x9c>
            key_pressed = keypad_vals;
            //_delay_ms(1);
   
            
            // Make rows as output and columns as input
            DDRD |= 0b11000000;
 1de:	9a b1       	in	r25, 0x0a	; 10
 1e0:	90 6c       	ori	r25, 0xC0	; 192
 1e2:	9a b9       	out	0x0a, r25	; 10
            DDRB = 0b00000011;
 1e4:	93 e0       	ldi	r25, 0x03	; 3
 1e6:	94 b9       	out	0x04, r25	; 4
 1e8:	ef e9       	ldi	r30, 0x9F	; 159
 1ea:	ff e0       	ldi	r31, 0x0F	; 15
 1ec:	31 97       	sbiw	r30, 0x01	; 1
 1ee:	f1 f7       	brne	.-4      	; 0x1ec <main+0xcc>
 1f0:	00 c0       	rjmp	.+0      	; 0x1f2 <main+0xd2>
 1f2:	00 00       	nop
            _delay_ms(1);
            
            // Power the column pins
            PORTB = 0b00111100;
 1f4:	9c e3       	ldi	r25, 0x3C	; 60
 1f6:	95 b9       	out	0x05, r25	; 5
            PORTD &= 0b00111111;
 1f8:	9b b1       	in	r25, 0x0b	; 11
 1fa:	9f 73       	andi	r25, 0x3F	; 63
 1fc:	9b b9       	out	0x0b, r25	; 11
 1fe:	ef e9       	ldi	r30, 0x9F	; 159
 200:	ff e0       	ldi	r31, 0x0F	; 15
 202:	31 97       	sbiw	r30, 0x01	; 1
 204:	f1 f7       	brne	.-4      	; 0x202 <main+0xe2>
 206:	00 c0       	rjmp	.+0      	; 0x208 <main+0xe8>
 208:	00 00       	nop
            _delay_ms(1);
            
            //printf("PINB %d   ", PINB);
            portd_vals = ((PIND & BITMASK_D) >> 6);
 20a:	99 b1       	in	r25, 0x09	; 9
            portb_vals = ((PINB & BITMASK_B) << 2);
 20c:	23 b1       	in	r18, 0x03	; 3
 20e:	30 e0       	ldi	r19, 0x00	; 0
 210:	22 0f       	add	r18, r18
 212:	33 1f       	adc	r19, r19
 214:	22 0f       	add	r18, r18
 216:	33 1f       	adc	r19, r19
            //printf("portb_vals %d   portd_vals %d ", portb_vals, portd_vals);
            
            //_delay_ms(10);
            keypad_vals = portd_vals | portb_vals;
            keypad_vals &= 0b11110000;
 218:	20 7f       	andi	r18, 0xF0	; 240
            
            //printf("PINB %d   ", PINB);
            //printf("Key pressed %d   ", key_pressed);
            //_delay_ms(10);
            key_pressed |= keypad_vals;    // The variable has now both row and column values
 21a:	82 2b       	or	r24, r18
            //printf("%d\n\r", key_pressed);
            
            if (key_pressed == 0b01110111) {
 21c:	87 37       	cpi	r24, 0x77	; 119
 21e:	51 f4       	brne	.+20     	; 0x234 <main+0x114>
                // Key 1 pressed
                printf("1");
 220:	81 e3       	ldi	r24, 0x31	; 49
 222:	90 e0       	ldi	r25, 0x00	; 0
 224:	0e 94 1a 02 	call	0x434	; 0x434 <putchar>
                given_password[idx] = '1';
 228:	81 e3       	ldi	r24, 0x31	; 49
 22a:	f8 01       	movw	r30, r16
 22c:	e0 50       	subi	r30, 0x00	; 0
 22e:	ff 4f       	sbci	r31, 0xFF	; 255
 230:	80 83       	st	Z, r24
 232:	b4 c0       	rjmp	.+360    	; 0x39c <main+0x27c>
                }
                else {
                    ;
                }
            }
            else if (key_pressed == 0b01111011) {
 234:	8b 37       	cpi	r24, 0x7B	; 123
 236:	51 f4       	brne	.+20     	; 0x24c <main+0x12c>
                // Key 2 pressed
                printf("2");
 238:	82 e3       	ldi	r24, 0x32	; 50
 23a:	90 e0       	ldi	r25, 0x00	; 0
 23c:	0e 94 1a 02 	call	0x434	; 0x434 <putchar>
                given_password[idx] = '2';
 240:	82 e3       	ldi	r24, 0x32	; 50
 242:	f8 01       	movw	r30, r16
 244:	e0 50       	subi	r30, 0x00	; 0
 246:	ff 4f       	sbci	r31, 0xFF	; 255
 248:	80 83       	st	Z, r24
 24a:	a8 c0       	rjmp	.+336    	; 0x39c <main+0x27c>
                }
                else {
                    ;
                }
            }
            else if (key_pressed == 0b01111101) {
 24c:	8d 37       	cpi	r24, 0x7D	; 125
 24e:	51 f4       	brne	.+20     	; 0x264 <main+0x144>
                // Key 3 pressed
                printf("3");
 250:	83 e3       	ldi	r24, 0x33	; 51
 252:	90 e0       	ldi	r25, 0x00	; 0
 254:	0e 94 1a 02 	call	0x434	; 0x434 <putchar>
                given_password[idx] = '3';
 258:	83 e3       	ldi	r24, 0x33	; 51
 25a:	f8 01       	movw	r30, r16
 25c:	e0 50       	subi	r30, 0x00	; 0
 25e:	ff 4f       	sbci	r31, 0xFF	; 255
 260:	80 83       	st	Z, r24
 262:	9c c0       	rjmp	.+312    	; 0x39c <main+0x27c>
                }
                else {
                    ;
                }
            }
            else if (key_pressed == 0b01111110) {
 264:	8e 37       	cpi	r24, 0x7E	; 126
 266:	51 f4       	brne	.+20     	; 0x27c <main+0x15c>
                // A
                printf("A");
 268:	81 e4       	ldi	r24, 0x41	; 65
 26a:	90 e0       	ldi	r25, 0x00	; 0
 26c:	0e 94 1a 02 	call	0x434	; 0x434 <putchar>
                given_password[idx] = 'A';
 270:	81 e4       	ldi	r24, 0x41	; 65
 272:	f8 01       	movw	r30, r16
 274:	e0 50       	subi	r30, 0x00	; 0
 276:	ff 4f       	sbci	r31, 0xFF	; 255
 278:	80 83       	st	Z, r24
 27a:	90 c0       	rjmp	.+288    	; 0x39c <main+0x27c>
                }
                else {
                    ;
                }
            }
            else if (key_pressed == 0b10110111) {
 27c:	87 3b       	cpi	r24, 0xB7	; 183
 27e:	51 f4       	brne	.+20     	; 0x294 <main+0x174>
                // 4
                printf("4");
 280:	84 e3       	ldi	r24, 0x34	; 52
 282:	90 e0       	ldi	r25, 0x00	; 0
 284:	0e 94 1a 02 	call	0x434	; 0x434 <putchar>
                given_password[idx] = '4';
 288:	84 e3       	ldi	r24, 0x34	; 52
 28a:	f8 01       	movw	r30, r16
 28c:	e0 50       	subi	r30, 0x00	; 0
 28e:	ff 4f       	sbci	r31, 0xFF	; 255
 290:	80 83       	st	Z, r24
 292:	84 c0       	rjmp	.+264    	; 0x39c <main+0x27c>
                }
                else {
                    ;
                }
            }
            else if (key_pressed == 0b10111011) {
 294:	8b 3b       	cpi	r24, 0xBB	; 187
 296:	51 f4       	brne	.+20     	; 0x2ac <main+0x18c>
                // 5
                printf("5");
 298:	85 e3       	ldi	r24, 0x35	; 53
 29a:	90 e0       	ldi	r25, 0x00	; 0
 29c:	0e 94 1a 02 	call	0x434	; 0x434 <putchar>
                given_password[idx] = '5';
 2a0:	85 e3       	ldi	r24, 0x35	; 53
 2a2:	f8 01       	movw	r30, r16
 2a4:	e0 50       	subi	r30, 0x00	; 0
 2a6:	ff 4f       	sbci	r31, 0xFF	; 255
 2a8:	80 83       	st	Z, r24
 2aa:	78 c0       	rjmp	.+240    	; 0x39c <main+0x27c>
                }
                else {
                    ;
                }
            }
            else if (key_pressed == 0b10111101) {
 2ac:	8d 3b       	cpi	r24, 0xBD	; 189
 2ae:	51 f4       	brne	.+20     	; 0x2c4 <main+0x1a4>
                // 6
                printf("6");
 2b0:	86 e3       	ldi	r24, 0x36	; 54
 2b2:	90 e0       	ldi	r25, 0x00	; 0
 2b4:	0e 94 1a 02 	call	0x434	; 0x434 <putchar>
                given_password[idx] = '6';
 2b8:	86 e3       	ldi	r24, 0x36	; 54
 2ba:	f8 01       	movw	r30, r16
 2bc:	e0 50       	subi	r30, 0x00	; 0
 2be:	ff 4f       	sbci	r31, 0xFF	; 255
 2c0:	80 83       	st	Z, r24
 2c2:	6c c0       	rjmp	.+216    	; 0x39c <main+0x27c>
                }
                else {
                    ;
                }
            }
            else if (key_pressed == 0b10111110) {
 2c4:	8e 3b       	cpi	r24, 0xBE	; 190
 2c6:	51 f4       	brne	.+20     	; 0x2dc <main+0x1bc>
                // B
                printf("B");
 2c8:	82 e4       	ldi	r24, 0x42	; 66
 2ca:	90 e0       	ldi	r25, 0x00	; 0
 2cc:	0e 94 1a 02 	call	0x434	; 0x434 <putchar>
                given_password[idx] = 'B';
 2d0:	82 e4       	ldi	r24, 0x42	; 66
 2d2:	f8 01       	movw	r30, r16
 2d4:	e0 50       	subi	r30, 0x00	; 0
 2d6:	ff 4f       	sbci	r31, 0xFF	; 255
 2d8:	80 83       	st	Z, r24
 2da:	60 c0       	rjmp	.+192    	; 0x39c <main+0x27c>
                }
                else {
                    ;
                }
            }
            else if (key_pressed == 0b11010111) {
 2dc:	87 3d       	cpi	r24, 0xD7	; 215
 2de:	51 f4       	brne	.+20     	; 0x2f4 <main+0x1d4>
                // 7
                printf("7");
 2e0:	87 e3       	ldi	r24, 0x37	; 55
 2e2:	90 e0       	ldi	r25, 0x00	; 0
 2e4:	0e 94 1a 02 	call	0x434	; 0x434 <putchar>
                given_password[idx] = '7';
 2e8:	87 e3       	ldi	r24, 0x37	; 55
 2ea:	f8 01       	movw	r30, r16
 2ec:	e0 50       	subi	r30, 0x00	; 0
 2ee:	ff 4f       	sbci	r31, 0xFF	; 255
 2f0:	80 83       	st	Z, r24
 2f2:	54 c0       	rjmp	.+168    	; 0x39c <main+0x27c>
                }
                else {
                    ;
                }
            }
            else if (key_pressed == 0b11011011) {
 2f4:	8b 3d       	cpi	r24, 0xDB	; 219
 2f6:	51 f4       	brne	.+20     	; 0x30c <main+0x1ec>
                // 8
                printf("8");
 2f8:	88 e3       	ldi	r24, 0x38	; 56
 2fa:	90 e0       	ldi	r25, 0x00	; 0
 2fc:	0e 94 1a 02 	call	0x434	; 0x434 <putchar>
                given_password[idx] = '8';
 300:	88 e3       	ldi	r24, 0x38	; 56
 302:	f8 01       	movw	r30, r16
 304:	e0 50       	subi	r30, 0x00	; 0
 306:	ff 4f       	sbci	r31, 0xFF	; 255
 308:	80 83       	st	Z, r24
 30a:	48 c0       	rjmp	.+144    	; 0x39c <main+0x27c>
                }
                else {
                    ;
                }
            }
            else if (key_pressed == 0b11011101) {
 30c:	8d 3d       	cpi	r24, 0xDD	; 221
 30e:	51 f4       	brne	.+20     	; 0x324 <main+0x204>
                // 9
                printf("9");
 310:	89 e3       	ldi	r24, 0x39	; 57
 312:	90 e0       	ldi	r25, 0x00	; 0
 314:	0e 94 1a 02 	call	0x434	; 0x434 <putchar>
                given_password[idx] = '9';
 318:	89 e3       	ldi	r24, 0x39	; 57
 31a:	f8 01       	movw	r30, r16
 31c:	e0 50       	subi	r30, 0x00	; 0
 31e:	ff 4f       	sbci	r31, 0xFF	; 255
 320:	80 83       	st	Z, r24
 322:	3c c0       	rjmp	.+120    	; 0x39c <main+0x27c>
                }
                else {
                    ;
                }
            }
            else if (key_pressed == 0b11011110) {
 324:	8e 3d       	cpi	r24, 0xDE	; 222
 326:	51 f4       	brne	.+20     	; 0x33c <main+0x21c>
                // C
                printf("C");
 328:	83 e4       	ldi	r24, 0x43	; 67
 32a:	90 e0       	ldi	r25, 0x00	; 0
 32c:	0e 94 1a 02 	call	0x434	; 0x434 <putchar>
                given_password[idx] = 'C';
 330:	83 e4       	ldi	r24, 0x43	; 67
 332:	f8 01       	movw	r30, r16
 334:	e0 50       	subi	r30, 0x00	; 0
 336:	ff 4f       	sbci	r31, 0xFF	; 255
 338:	80 83       	st	Z, r24
 33a:	30 c0       	rjmp	.+96     	; 0x39c <main+0x27c>
                }
                else {
                    ;
                }
            }
            else if (key_pressed == 0b11100111) {
 33c:	87 3e       	cpi	r24, 0xE7	; 231
 33e:	51 f4       	brne	.+20     	; 0x354 <main+0x234>
                // *
                printf("*");
 340:	8a e2       	ldi	r24, 0x2A	; 42
 342:	90 e0       	ldi	r25, 0x00	; 0
 344:	0e 94 1a 02 	call	0x434	; 0x434 <putchar>
                // TODO: make this the backspace button
                given_password[idx] = '*';
 348:	8a e2       	ldi	r24, 0x2A	; 42
 34a:	f8 01       	movw	r30, r16
 34c:	e0 50       	subi	r30, 0x00	; 0
 34e:	ff 4f       	sbci	r31, 0xFF	; 255
 350:	80 83       	st	Z, r24
 352:	24 c0       	rjmp	.+72     	; 0x39c <main+0x27c>
                }
                else {
                    ;
                }
            }
            else if (key_pressed == 0b11101011) {
 354:	8b 3e       	cpi	r24, 0xEB	; 235
 356:	51 f4       	brne	.+20     	; 0x36c <main+0x24c>
                // 0
                printf("0");
 358:	80 e3       	ldi	r24, 0x30	; 48
 35a:	90 e0       	ldi	r25, 0x00	; 0
 35c:	0e 94 1a 02 	call	0x434	; 0x434 <putchar>
                given_password[idx] = '0';
 360:	80 e3       	ldi	r24, 0x30	; 48
 362:	f8 01       	movw	r30, r16
 364:	e0 50       	subi	r30, 0x00	; 0
 366:	ff 4f       	sbci	r31, 0xFF	; 255
 368:	80 83       	st	Z, r24
 36a:	18 c0       	rjmp	.+48     	; 0x39c <main+0x27c>
                }
                else {
                    ;
                }
            }
            else if (key_pressed == 0b11101101) {
 36c:	8d 3e       	cpi	r24, 0xED	; 237
 36e:	59 f4       	brne	.+22     	; 0x386 <main+0x266>
                // #
                printf("#");
 370:	83 e2       	ldi	r24, 0x23	; 35
 372:	90 e0       	ldi	r25, 0x00	; 0
 374:	0e 94 1a 02 	call	0x434	; 0x434 <putchar>
                compare(password, given_password);
 378:	60 e0       	ldi	r22, 0x00	; 0
 37a:	71 e0       	ldi	r23, 0x01	; 1
 37c:	85 e0       	ldi	r24, 0x05	; 5
 37e:	91 e0       	ldi	r25, 0x01	; 1
 380:	0e 94 78 00 	call	0xf0	; 0xf0 <compare>
 384:	0b c0       	rjmp	.+22     	; 0x39c <main+0x27c>
                //printf("#");
                //given_password[idx] = '#';
                //led_test();
            }
            else if (key_pressed == 0b11101110) {
 386:	8e 3e       	cpi	r24, 0xEE	; 238
 388:	49 f4       	brne	.+18     	; 0x39c <main+0x27c>
                // D
                printf("D");
 38a:	84 e4       	ldi	r24, 0x44	; 68
 38c:	90 e0       	ldi	r25, 0x00	; 0
 38e:	0e 94 1a 02 	call	0x434	; 0x434 <putchar>
                given_password[idx] = 'D';
 392:	84 e4       	ldi	r24, 0x44	; 68
 394:	f8 01       	movw	r30, r16
 396:	e0 50       	subi	r30, 0x00	; 0
 398:	ff 4f       	sbci	r31, 0xFF	; 255
 39a:	80 83       	st	Z, r24
                }
            }
            
            /* Initialization for new loop */
            // Set digital pins 6-9 (rows) as input and 10-13 (columns) as output
            DDRD &= 0b00111111;
 39c:	8a b1       	in	r24, 0x0a	; 10
 39e:	8f 73       	andi	r24, 0x3F	; 63
 3a0:	8a b9       	out	0x0a, r24	; 10
            DDRB &= 0b11111100;
 3a2:	84 b1       	in	r24, 0x04	; 4
 3a4:	8c 7f       	andi	r24, 0xFC	; 252
 3a6:	84 b9       	out	0x04, r24	; 4
            DDRB |= 0b00111100;
 3a8:	84 b1       	in	r24, 0x04	; 4
 3aa:	8c 63       	ori	r24, 0x3C	; 60
 3ac:	84 b9       	out	0x04, r24	; 4
 3ae:	8f e9       	ldi	r24, 0x9F	; 159
 3b0:	9f e0       	ldi	r25, 0x0F	; 15
 3b2:	01 97       	sbiw	r24, 0x01	; 1
 3b4:	f1 f7       	brne	.-4      	; 0x3b2 <main+0x292>
 3b6:	00 c0       	rjmp	.+0      	; 0x3b8 <main+0x298>
 3b8:	00 00       	nop
            _delay_ms(1);
    
            // Power the row pins
            PORTD |= 0b11000000;
 3ba:	8b b1       	in	r24, 0x0b	; 11
 3bc:	80 6c       	ori	r24, 0xC0	; 192
 3be:	8b b9       	out	0x0b, r24	; 11
            PORTB |= 0b00000011;
 3c0:	85 b1       	in	r24, 0x05	; 5
 3c2:	83 60       	ori	r24, 0x03	; 3
 3c4:	85 b9       	out	0x05, r24	; 5
            PORTB &= 0b11000011;
 3c6:	85 b1       	in	r24, 0x05	; 5
 3c8:	83 7c       	andi	r24, 0xC3	; 195
 3ca:	85 b9       	out	0x05, r24	; 5
 3cc:	ef e9       	ldi	r30, 0x9F	; 159
 3ce:	ff e0       	ldi	r31, 0x0F	; 15
 3d0:	31 97       	sbiw	r30, 0x01	; 1
 3d2:	f1 f7       	brne	.-4      	; 0x3d0 <main+0x2b0>
 3d4:	00 c0       	rjmp	.+0      	; 0x3d6 <main+0x2b6>
 3d6:	00 00       	nop
            _delay_ms(1);

            
            key_pressed = 0;
            idx +=1;
 3d8:	0f 5f       	subi	r16, 0xFF	; 255
 3da:	1f 4f       	sbci	r17, 0xFF	; 255
 3dc:	ff ef       	ldi	r31, 0xFF	; 255
 3de:	21 ee       	ldi	r18, 0xE1	; 225
 3e0:	34 e0       	ldi	r19, 0x04	; 4
 3e2:	f1 50       	subi	r31, 0x01	; 1
 3e4:	20 40       	sbci	r18, 0x00	; 0
 3e6:	30 40       	sbci	r19, 0x00	; 0
 3e8:	e1 f7       	brne	.-8      	; 0x3e2 <main+0x2c2>
 3ea:	00 c0       	rjmp	.+0      	; 0x3ec <main+0x2cc>
 3ec:	00 00       	nop
 3ee:	e6 ce       	rjmp	.-564    	; 0x1bc <main+0x9c>

000003f0 <USART_init>:
#include <stdio.h>


void USART_init(unsigned int ubrr) {
	// Set baud rate
	UBRR0H = (unsigned char) (ubrr>>8);
 3f0:	90 93 c5 00 	sts	0x00C5, r25	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7f80c5>
	UBRR0L = (unsigned char) ubrr;
 3f4:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7f80c4>
	
	// Enable receiver and transmitter
	UCSR0B = (1<<RXEN0) | (1<<TXEN0);
 3f8:	88 e1       	ldi	r24, 0x18	; 24
 3fa:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7f80c1>
	
	// Set frame format: 8data, 2stop bit
	UCSR0C = (1<<USBS0) | (3<<UCSZ00);
 3fe:	8e e0       	ldi	r24, 0x0E	; 14
 400:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7f80c2>
 404:	08 95       	ret

00000406 <USART_transmit>:
}

void USART_transmit(unsigned char data) {
	// Wait for empty transmit buffer
	while(!(UCSR0A & (1<<UDRE0)));
 406:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7f80c0>
 40a:	95 ff       	sbrs	r25, 5
 40c:	fc cf       	rjmp	.-8      	; 0x406 <USART_transmit>
    
	// Put data into buffer, send the data
	UDR0 = data;
 40e:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7f80c6>
 412:	08 95       	ret

00000414 <USART_receive>:
}

unsigned char USART_receive(void) {
	// Wait for data to be received
	while(!(UCSR0A & (1<<RXC0)));
 414:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7f80c0>
 418:	88 23       	and	r24, r24
 41a:	e4 f7       	brge	.-8      	; 0x414 <USART_receive>
	
	// Get and return received data from buffer
	return UDR0;
 41c:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7f80c6>
}
 420:	08 95       	ret

00000422 <strcmp>:
 422:	fb 01       	movw	r30, r22
 424:	dc 01       	movw	r26, r24
 426:	8d 91       	ld	r24, X+
 428:	01 90       	ld	r0, Z+
 42a:	80 19       	sub	r24, r0
 42c:	01 10       	cpse	r0, r1
 42e:	d9 f3       	breq	.-10     	; 0x426 <strcmp+0x4>
 430:	99 0b       	sbc	r25, r25
 432:	08 95       	ret

00000434 <putchar>:
 434:	60 91 0c 01 	lds	r22, 0x010C	; 0x80010c <__data_end+0x2>
 438:	70 91 0d 01 	lds	r23, 0x010D	; 0x80010d <__data_end+0x3>
 43c:	0e 94 21 02 	call	0x442	; 0x442 <fputc>
 440:	08 95       	ret

00000442 <fputc>:
 442:	0f 93       	push	r16
 444:	1f 93       	push	r17
 446:	cf 93       	push	r28
 448:	df 93       	push	r29
 44a:	fb 01       	movw	r30, r22
 44c:	23 81       	ldd	r18, Z+3	; 0x03
 44e:	21 fd       	sbrc	r18, 1
 450:	03 c0       	rjmp	.+6      	; 0x458 <fputc+0x16>
 452:	8f ef       	ldi	r24, 0xFF	; 255
 454:	9f ef       	ldi	r25, 0xFF	; 255
 456:	2c c0       	rjmp	.+88     	; 0x4b0 <fputc+0x6e>
 458:	22 ff       	sbrs	r18, 2
 45a:	16 c0       	rjmp	.+44     	; 0x488 <fputc+0x46>
 45c:	46 81       	ldd	r20, Z+6	; 0x06
 45e:	57 81       	ldd	r21, Z+7	; 0x07
 460:	24 81       	ldd	r18, Z+4	; 0x04
 462:	35 81       	ldd	r19, Z+5	; 0x05
 464:	42 17       	cp	r20, r18
 466:	53 07       	cpc	r21, r19
 468:	44 f4       	brge	.+16     	; 0x47a <fputc+0x38>
 46a:	a0 81       	ld	r26, Z
 46c:	b1 81       	ldd	r27, Z+1	; 0x01
 46e:	9d 01       	movw	r18, r26
 470:	2f 5f       	subi	r18, 0xFF	; 255
 472:	3f 4f       	sbci	r19, 0xFF	; 255
 474:	31 83       	std	Z+1, r19	; 0x01
 476:	20 83       	st	Z, r18
 478:	8c 93       	st	X, r24
 47a:	26 81       	ldd	r18, Z+6	; 0x06
 47c:	37 81       	ldd	r19, Z+7	; 0x07
 47e:	2f 5f       	subi	r18, 0xFF	; 255
 480:	3f 4f       	sbci	r19, 0xFF	; 255
 482:	37 83       	std	Z+7, r19	; 0x07
 484:	26 83       	std	Z+6, r18	; 0x06
 486:	14 c0       	rjmp	.+40     	; 0x4b0 <fputc+0x6e>
 488:	8b 01       	movw	r16, r22
 48a:	ec 01       	movw	r28, r24
 48c:	fb 01       	movw	r30, r22
 48e:	00 84       	ldd	r0, Z+8	; 0x08
 490:	f1 85       	ldd	r31, Z+9	; 0x09
 492:	e0 2d       	mov	r30, r0
 494:	09 95       	icall
 496:	89 2b       	or	r24, r25
 498:	e1 f6       	brne	.-72     	; 0x452 <fputc+0x10>
 49a:	d8 01       	movw	r26, r16
 49c:	16 96       	adiw	r26, 0x06	; 6
 49e:	8d 91       	ld	r24, X+
 4a0:	9c 91       	ld	r25, X
 4a2:	17 97       	sbiw	r26, 0x07	; 7
 4a4:	01 96       	adiw	r24, 0x01	; 1
 4a6:	17 96       	adiw	r26, 0x07	; 7
 4a8:	9c 93       	st	X, r25
 4aa:	8e 93       	st	-X, r24
 4ac:	16 97       	sbiw	r26, 0x06	; 6
 4ae:	ce 01       	movw	r24, r28
 4b0:	df 91       	pop	r29
 4b2:	cf 91       	pop	r28
 4b4:	1f 91       	pop	r17
 4b6:	0f 91       	pop	r16
 4b8:	08 95       	ret

000004ba <_exit>:
 4ba:	f8 94       	cli

000004bc <__stop_program>:
 4bc:	ff cf       	rjmp	.-2      	; 0x4bc <__stop_program>
